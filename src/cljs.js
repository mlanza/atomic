import {overload, curry, partial, constantly, identity, add, substract, multiply, divide, reducing, unspread} from './core';
import {EMPTY} from './types/empty';
import * as c from './coll';
import * as t from './transducer';
export {update, updateIn, assocIn, getIn, some, someFn, everyPred, isEvery, isAny, isNotAny, iterate, cycle, each} from './coll';
export {first, rest} from './protocols/seq';
export {next} from './protocols/next';
export {seq} from './protocols/seqable';
export {nth} from './protocols/indexed';
export {count} from './protocols/counted';
export {reduce} from './protocols/reduce';
export {reduceKv} from './protocols/reduce-kv';
export {parent, closest, detach} from './protocols/hierarchy';
export {hasKey} from './protocols/associative';
import * as associative from './protocols/associative';
export {empty} from './protocols/emptyable';
export {get} from './protocols/lookup';
export {query, fetch} from './protocols/query';
export {conj} from './protocols/collection';
export {append} from './protocols/append';
export {prepend} from './protocols/prepend';
export {swap} from './protocols/swap';
export {deref} from './protocols/deref';
export {reset} from './protocols/reset';
export {publish} from './protocols/publish';
export {subscribe} from './protocols/subscribe';
export const inc          = partial(add, +1);
export const dec          = partial(add, -1);
export const TRUE         = constantly(true);
export const FALSE        = constantly(false);
export const ZERO         = constantly(0);
export const ONE          = constantly(1);
export const repeat       = overload(null, c.repeat, c.repeatN);
export const into         = overload(null, null, c.into, c.intoX);
export const transduce    = overload(null, null, null, c.transduce3, c.transduce4);
export const cons         = overload(constantly(EMPTY), c.cons, c.cons, c.consN);
export const map          = overload(null, t.map, c.map, c.mapN);
export const mapIndexed   = overload(null, t.mapIndexed, c.mapIndexed);
export const filter       = overload(null, t.filter, c.filter);
export const remove       = overload(null, t.remove, c.remove);
export const find         = overload(null, t.find, c.find);
export const takeWhile    = overload(null, t.takeWhile, c.takeWhile);
export const take         = overload(null, t.take, c.take);
export const takeNth      = overload(null, t.takeNth, c.takeNth);
export const drop         = overload(null, t.drop, c.drop);
export const dropWhile    = overload(null, t.dropWhile, c.dropWhile);
export const keep         = overload(null, t.keep, c.keep);
export const keepIndexed  = overload(null, t.keepIndexed, c.keepIndexed);
export const interpose    = overload(null, t.interpose, c.interpose);
export const dedupe       = overload(t.dedupe, c.dedupe);
export const distinct     = overload(t.distinct, c.distinct);
export const partition    = overload(null, null, c.partition, c.partitionStep, c.partitionStepPad);
export const partitionBy  = overload(null, null, c.partitionBy); //TODO transducer
export const partitionAll = overload(null, null, c.partitionAll, c.partitionAllStep); //TODO transducer
export const sort         = overload(null, c.sort, c.sortWith);
export const sortBy       = overload(null, null, c.sortBy, c.sortByWith);
export const eq           = overload(TRUE , TRUE , c.eq , c.scanning(c.eq));
export const ne           = overload(FALSE, FALSE, c.ne , c.scanning(c.ne));
export const gt           = overload(FALSE, TRUE , c.gt , c.scanning(c.gt));
export const gte          = overload(TRUE , TRUE , c.gte, c.scanning(c.gte));
export const lt           = overload(FALSE, TRUE , c.lt , c.scanning(c.lt));
export const lte          = overload(TRUE , TRUE , c.lte, c.scanning(c.lte));
export const assoc        = overload(null, null, null, associative.assoc, c.assocN);
export const dissoc       = overload(null, null, associative.dissoc, c.dissocN);
export const doall        = overload(null, c.doall, c.doallTimes);
export const dropLast     = overload(null, c.butlast, c.dropLast);
export const str          = overload(constantly(""), c.str, c.strN);
export const repeatedly   = overload(null, c.repeatedly, c.repeatedlyN);
export const plus         = overload(ZERO, identity, add, reducing(add));
export const minus        = overload(ZERO, partial(multiply, -1), subtract, reducing(subtract));
export const mult         = overload(ONE, identity, multiply, reducing(multiply));
export const div          = overload(constantly(NaN), partial(divide, 1), divide, reducing(divide));
export const max          = overload(null, identity, unspread(c.max));
export const min          = overload(null, identity, unspread(c.min));
